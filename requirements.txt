# CodeSwipe Application Requirements

This document outlines the functional and API requirements for the CodeSwipe web application.

---
## 1. User Authentication

### 1.1. Login Page
- **FR1.1.1:** Users must be able to sign in/sign up using their Google account.
- **FR1.1.2:** The page must display the application name ("CodeSwipe") and a clear call-to-action button for Google Sign-In.
- **FR1.1.3:** The system must provide visual feedback during the sign-in process (e.g., a loading state).
- **FR1.1.4:** Any sign-in errors (e.g., pop-up blocked, unauthorized domain) must be clearly displayed to the user.

### 1.2. Onboarding Flow (First-time Users)
- **FR1.2.1:** A multi-step modal shall be displayed to new users after their first successful login.
- **FR1.2.2:** Step 1: Welcome screen.
- **FR1.2.3:** Step 2: User must select their current skill level (e.g., Beginner, Intermediate, Advanced).
- **FR1.2.4:** Step 3: User must select one or more preferred programming languages.
- **FR1.2.5:** Step 4: User must select their primary goal (e.g., Interview Prep, Daily Practice).
- **FR1.2.6:** Users must have the option to skip the onboarding process.
- **FR1.2.7:** The selected preferences must be saved to the user's profile.

### 1.3. Logout
- **FR1.3.1:** Logged-in users must be able to sign out of the application via a button in their profile modal.

---
## 2. Main Application - Challenge Viewer

### 2.1. Challenge Feed
- **FR2.1.1:** The main view must display one coding challenge at a time.
- **FR2.1.2:** Users must be able to navigate to the next and previous challenges (e.g., using on-screen buttons or swipe gestures).
- **FR2.1.3:** Each challenge card must display the title, description, difficulty level, and programming language.

### 2.2. Code Editor
- **FR2.2.1:** An in-browser code editor (textarea) must be provided for each challenge.
- **FR2.2.2:** The editor must be pre-populated with starter code relevant to the challenge.
- **FR2.2.3:** Users must be able to write and edit code freely within the editor.

### 2.3. Code Execution & Testing
- **FR2.3.1:** A "Run Tests" button must be available to submit the user's code for evaluation.
- **FR2.3.2:** The system must provide a loading state while the code is being executed and evaluated.
- **FR2.3.3:** The results of the evaluation must be displayed below the editor.
- **FR2.3.4:** For each test case, the result must show a "Passed" or "Failed" status.
- **FR2.3.5:** For failed test cases, the display must include the input, the expected output, and the actual output received from the user's code.
- **FR2.3.6:** Any runtime or syntax errors from the code execution must be displayed to the user.

---
## 3. User Profile & Settings (Modals)

### 3.1. Profile Modal
- **FR3.1.1:** Must display the user's profile information: profile picture, display name, and email from their Google account.
- **FR3.1.2:** Must display the date the user's account was created ("Member since").
- **FR3.1.3:** Must contain the "Sign Out" button.

### 3.2. Settings Modal
- **FR3.2.1:** Users must be able to view and update their preferences, including:
    - Skill Level
    - Preferred Programming Languages
    - Challenge Topics of Interest
- **FR3.2.2:** A "Save Settings" button must persist these changes to the user's profile.

### 3.3. Achievements Modal
- **FR3.3.1:** The system shall display a list of all challenges the user has successfully completed.  

### 3.4. About Modal
- **FR3.4.1:** Must display information about the CodeSwipe application, its purpose, and its creation for the Google Cloud Run Hackathon.

---
## 4. API Requirements (for backend development)

### 4.1. Authentication
- Uses Firebase Authentication for Google Sign-In. No custom endpoints are needed.

### 4.2. Users & Settings
- **`GET /api/users/me`**
    - **Description:** Fetches the profile and settings for the currently authenticated user.
    - **Response:** User object containing `displayName`, `email`, `photoURL`, `creationTime`, and a `settings` object (`level`, `languages`, `topics`).
- **`PUT /api/users/me/settings`**
    - **Description:** Updates the settings for the currently authenticated user.
    - **Request Body:** A `settings` object containing `level`, `languages`, `topics`.
    - **Response:** Success/failure message.

### 4.3. Challenges
- **`GET /api/challenges`**
    - **Description:** Fetches a list of challenges personalized to the user's settings.
    - **Query Params:** `level`, `languages[]`, `topics[]`.
    - **Response:** An array of Challenge objects, each containing `id`, `title`, `description`, `language`, `difficulty`, `starterCode`, and `testCases`.

### 4.4. Code Evaluation
- **`POST /api/evaluate`**
    - **Description:** Securely executes user-submitted code against a challenge's test cases.
    - **Request Body:** `{ "challengeId": "string", "userCode": "string", "language": "string" }`
    - **Response:** An array of Test Result objects, each containing `input`, `expected`, `actual`, `passed`, and any `error` messages.

### 4.5. Achievements
- **`GET /api/users/me/achievements`**
    - **Description:** Fetches a list of challenges successfully solved by the user.
    - **Response:** An array of lightweight Challenge objects (e.g., `id`, `title`, `language`, `completionDate`).
- **`POST /api/submissions`**
    - **Description:** Records a user's successful submission for a challenge.
    - **Request Body:** `{ "challengeId": "string", "solutionCode": "string", "passedAllTests": true }`
    - **Response:** Success/failure message.

 

1) Set project and variables

$PROJECT_ID = (gcloud config get-value project)$REGION = "us-central1" $SA_NAME = "curator-sa


2) Enable required APIs (safe to rerun)
gcloud services enable run.googleapis


3) Create the service account
gcloud iam service-accounts create $SA_NAME --display-name "Curator Agent Service Account"


4) Grant minimal roles to the service account

gcloud projects add-iam-policy-binding $PROJECT_ID `  --member="serviceAccount:$SA" `  --role="roles/datastore.user"gcloud projects add-iam-policy-binding $PROJECT_ID `  --member="serviceAccount:$SA" `  --role="roles/secretmanager.secretAccessor"


5) Put the Gemini API key into Secret Manager (PowerShell-friendly)
Replace YOUR_NEW_GEMINI_API_KEY with your rotated key.

Set-Content -Path gemini.key -NoNewline -Value " "gcloud secrets create GEMINI_API_KEY --replication-policy="automatic" --data-file=gemini.keyRemove-Item gemini.key


If you need to rotate later:
Set-Content -Path gemini.key -NoNewline -Value "ROTATED_KEY"gcloud secrets versions add GEMINI_API_KEY --data-file=gemini.keyRemove-Item gemini.key
Next (when ready to deploy the Curator):
Build and deploy your Curator container to Cloud Run with the secret injected:
gcloud builds submit --tag gcr.io/$PROJECT_ID/curator:latestgcloud run deploy curator-service `  --image gcr.io/$PROJECT_ID/curator:latest `  --region $REGION `  --service-account $SA `  --set-secrets GEMINI_API_KEY=GEMINI_API_KEY:latest `  --set-env-vars CORS_ALLOWED_ORIGINS=http://localhost:3000 `  --allow-unauthenticated=false
That’s all you need for the secure key handling and IAM. When you’re ready, I can add a minimal Curator API handler and the frontend fetch to call i


Set-Content -Path gemini.key -NoNewline -Value " "
gcloud secrets create GEMINI_API_KEY --replication-policy="automatic" --data-file=gemini.key
Remove-Item gemini.key




1) Pick project and enable services
Go to Google Cloud Console → top navbar, select your project.
APIs & Services → Enable APIs and Services → enable:
Cloud Run API
Secret Manager API
Firestore API
Firestore → Create database (Native mode) if not already.
2) Create the service account
IAM & Admin → Service Accounts → Create service account
Name: curator-sa
Roles:
Cloud Datastore User
Secret Manager Secret Accessor
Create.
3) Store the Gemini key in Secret Manager
Security → Secret Manager → Create Secret
Name: GEMINI_API_KEY
Value: your rotated Gemini key (do NOT use the one in requirements.txt)
Create.
4) Build or choose your Curator container (can do later)
If you already have an image: skip to step 5.
Otherwise, when ready, push an image (we can handle this after the UI steps).
5) Deploy Curator to Cloud Run (and bind the secret)
Cloud Run → Create Service
Container image: gcr.io/PROJECT_ID/curator:latest (or pick from “Select”)
Service account: curator-sa@PROJECT_ID.iam.gserviceaccount.com
Authentication: Require authentication (don’t allow unauthenticated)
Variables & secrets → Secrets → Add secret:
Name: GEMINI_API_KEY
Environment variable: GEMINI_API_KEY
Advanced settings (optional):
Ingress: Allow all
Min instances: 0
Set env var CORS_ALLOWED_ORIGINS = http://localhost:3000 (optional for dev)
Deploy.
6) Verify
Secret Manager → GEMINI_API_KEY → “Usage” tab should list your Cloud Run service.
Cloud Run → your service → Details shows the service account and secret env var.
Logs → confirm it starts cleanly.
Notes
Remove and rotate any key present in requirements.txt.
Frontend must call the Curator endpoint; never expose the key client-side.
When you’re ready, I can add a minimal Curator API in your repo and wire the frontend call.